<!DOCTYPE html>
<html>

<head>
  <title>A STAB at Optics in One Hour</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body {
      font-family: 'Droid Serif', 'Helvetica';
      /*line-height: 1.25em;*/
    }

    li {
      margin: 10px 0;
    }

    h1,
    h2,
    h3 {
      font-family: 'Yanone Kaffeesatz', 'Gill Sans';
      font-weight: normal;
    }

    img {
      width: 50%;
      height: 50%;
      object-fit: contain;
    }

    .remark-code,
    .remark-inline-code {
      font-family: 'Ubuntu Mono', 'Consolas', 'Courier New';
    }
  </style>
</head>

<body>
  <textarea id="source">

class: center, middle

# A STAB at Optics in One Hour
James Santucci â€¢ `@jisantuc`

@47Degrees / @jisantuc

???

Questions whenever, please interrupt

---

## Why optics?

[Haskell (Almost) Standard Libraries](https://leanpub.com/haskell-stdlibs), introduction to Ch. 10, Optics:

> Modern languages like Scala, Kotlin, or Javascript (since ES6) force you to choose
> between [immutability and mutability] at each declaration [...] Immutability is better overall:
> you get more guaratees and easier asynchronous programming [...] However, this syntax is so, so sweet:
>
> `person.name.first = "Alex"`
>
> [...] It turns out this is a false dichotomy.

<!-- general purpose toolkit for describing traversal and manipulation of complex objects that are
_values_ (so can be passed around easily) and _composable_ (like function composition -- just gotta glue
the types on the ends together and you're good to go) -->

---

## Why optics?

Understand [this blog post](https://chrispenner.ca/posts/traversal-systems):

> A Traversal System allows you dive deeply into a piece of data and may allow
> you to fetch, query, and edit the structure as you go while maintaining references
> to other pieces of the structure to influence your work.

<!-- we can glue optics together with other nice functional abstractions and become
_very powerful_ -->

---

## Why optics?

polymorphic _extreme sports_

```haskell
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
```

![](./mountain-bike-cat.png)

---

# Roadmap

- simple optics on case classes
- simple optics on sum types
- indexed optics and traversals
- API comparisons -- Monocle and `microlens`

---

class: center, middle

# Simple optics on case classes


---

## Lenses -- getters and setters

```scala
sealed abstract class AnimalType(val repr: String) {
  override def toString: String = repr
}
case object Dog extends AnimalType("dog")
case object Cat extends AnimalType("cat")

case class Address(street: String, houseNumber: Int)
case class Pet(name: String, _type: AnimalType, age: Int)
case class Person(name: String, address: Address, pets: List[Pet])

val me = Person("James", Address("Denver somewhere", 23), Nil)
// me: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 23),
//   pets = List()
// )
```

---

## Lenses -- getters and setters

- congrats to me, I got a dog! (not in real life)

```scala
val dogOwningMe = me.copy(pets = List(Pet("Aristophanes", Dog, 4)))
// dogOwningMe: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 23),
//   pets = List(Pet(name = "Aristophanes", _type = dog, age = 4))
// )
```

--

- congrats to me, I got another dog! (also not in real life)

```scala
val twoDogsMe = dogOwningMe.copy(pets = dogOwningMe.pets :+ Pet("Aeschelus", Dog, 7))
// twoDogsMe: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 23),
//   pets = List(
//     Pet(name = "Aristophanes", _type = dog, age = 4),
//     Pet(name = "Aeschelus", _type = dog, age = 7)
//   )
// )
```

---

## Lenses -- getters and setters

- oh and I moved

```scala
val upTheStreet = twoDogsMe.copy(
  address = twoDogsMe.address.copy(
    houseNumber = twoDogsMe.address.houseNumber + 8
  )
)
// upTheStreet: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 31),
//   pets = List(
//     Pet(name = "Aristophanes", _type = dog, age = 4),
//     Pet(name = "Aeschelus", _type = dog, age = 7)
//   )
// )
```

---

## Lenses -- getters and setters

all at once:

```scala
me.copy(
  pets = me.pets ++ List(Pet("Aristophanes", Dog, 4), Pet("Aeschelus", Dog, 7)),
  address = me.address.copy(houseNumber = me.address.houseNumber + 8)
)
// res0: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 31),
//   pets = List(
//     Pet(name = "Aristophanes", _type = dog, age = 4),
//     Pet(name = "Aeschelus", _type = dog, age = 7)
//   )
// )
```

<!-- `me` shows up four times in that update;
also in the previous examples, I had to make sure that I used the right copy of me while I sequenced
the updates, which is easy to mess up because everything conforms to the type -->

<!-- without optics, _describe_ and _apply_ the change at the same time; this is a bit familiar to effect systems,
where we want to separate description of effectful programs from their execution, but we don't have effects here -->

<!-- what do we have instead? something like "describe the path to some data of interest, and separate that description
from what we want to do when we get there" -->

---

## Lenses -- getters and setters

```scala
val petsLens = GenLens[Person](_.pets)
val addressLens = GenLens[Person](_.address)
val houseNumberLens = GenLens[Address](_.houseNumber)

def acquirePet(pet: Pet): Person => Person =
  petsLens.modify(_ :+ pet)

def moveUpTheStreet(howFar: Int): Person => Person =
  addressLens.andThen(houseNumberLens).modify(_ + howFar)
```

<!-- what's up here -- we can ask Monocle to write lenses for us for case classes
pretty easily by describing how to get to the field we care about, so for instance
petsLens is a path from a Person to their List[Pet]

.modify on a lens let's us apply an A => A function on whatever path is described by the
lens

we can compose paths, as long as they connect, e.g. in move up the street we follow the
path described by addressLens, then the path from there to houseNumber, before applying
the modification

the resulting types of these path descriptions into Person objects just end up as
functions waiting for some Person value to oeprate on. _separation complete_. cool! -->

---

## Lenses -- getters and setters

```scala
val bigLifeChanges = moveUpTheStreet(8)
  .compose(acquirePet(Pet("Aristophanes", Dog, 4)))
  .compose(acquirePet(Pet("Aeschelus", Dog, 7)))
// bigLifeChanges: Person => Person = scala.Function1$$Lambda$51247/693794206@3231eb45

bigLifeChanges(me)
// res1: Person = Person(
//   name = "James",
//   address = Address(street = "Denver somewhere", houseNumber = 31),
//   pets = List(
//     Pet(name = "Aeschelus", _type = dog, age = 7),
//     Pet(name = "Aristophanes", _type = dog, age = 4)
//   )
// )
```

<!-- since we just end up with functions at the end, we can compose them -->

---

## Lenses -- getters and setters

- alternate syntax:

```scala
val acquirePet2 = (pet: Pet) => (person: Person) =>
  person.focus(_.pets).modify(_ :+ pet)
// acquirePet2: Pet => Person => Person = <function1>

def moveUpTheStreet2 = (howFar: Int) => (person: Person) =>
  person.focus(_.address.houseNumber).modify(_ + howFar)

val bigLifeChanges2 = acquirePet2(Pet("Aristophanes", Dog, 4))
  .compose(acquirePet2(Pet("Aeschelus", Dog, 7)))
  .compose(moveUpTheStreet2(8))
// bigLifeChanges2: Person => Person = scala.Function1$$Lambda$51247/693794206@3339c66c

bigLifeChanges2(me) == bigLifeChanges(me)
// res2: Boolean = true
```

<!-- person.focus is a macro that creates the required Lens at compile time,
but it works the same; argument orders here are carefully chosen for nice composition
at the end, vals instead of defs because Scala maintains some differences in APIs
for function values and methods created with def (e.g. with these vals, don't need the trailing
_ to indicate a partially applied function) -->

---

## Lenses -- getters and setters

- focused on updates so far, but we can also just view what's at a path instead, e.g.:

```scala
addressLens.andThen(houseNumberLens).get(me)
// res3: Int = 23
```

--

- if you want, you can [generate all the lenses](https://www.optics.dev/Monocle/docs/optics/lens#lens-generation)
  since no one likes writing boilerplate
- maybe more useful in a library setting, since you're providing convenient syntax to end users rather than
  creating and consuming lenses all in one go, e.g.,
  [doobie](https://tpolecat.github.io/doobie/docs/14-Managing-Connections.html#customizing-transactors) provides
  lenses for customizing transactor behavior

<!-- that's more useful for library authors I think than applications, since in an application setting
you know which specific lenses you care about creating / ad hoc providing via .focus to accomplish your
specific goals;  -->

---

# Roadmap

- ~~simple optics on case classes~~
- simple optics on sum types
- indexed optics and traversals
- API comparisons -- Monocle and `microlens`

---

class: center, middle

# Simple optics on sum types

---

# Roadmap

- ~~simple optics on case classes~~
- ~~simple optics on sum types~~
- indexed optics and traversals
- API comparisons -- Monocle and `microlens`

---

class: center, middle

# Indexed optics and traversals

---

# Roadmap

- ~~simple optics on case classes~~
- ~~simple optics on sum types~~
- ~~indexed optics and traversals~~
- API comparison -- Monocle and `microlens`

---

class: center, middle

# API comparison -- Monocle and `microlens`

---

## Comparing Monocle and Haskell libs

- why bother? Googling for optics things frequently turns up Haskell libs
- comparison in this case: [`microlens`](https://hackage.haskell.org/package/microlens)

<!-- why microlens? mentioned in Haskell (Almost) Standard Libraries as go-to for optics at this point; doesn't require
discussion of different optic encodings like `optics` would, API similar to Ed Kmett's big lens package -->

---

class: center, middle

# A section title slide

---

## A normal slide

---

## A slide with evaluated code

- point to a whole new database that lives somewhere else

```scala
// treat these as newtypes for non-empty strings
type DatabaseUser = String
type DatabaseHost = String
type DatabasePassword = String

case class DatabaseConfig(
  dbUser: DatabaseUser,
  dbHost: DatabaseHost,
  dbPassword: DatabasePassword
)
```

---

## A slide with evaluated code with no output

- command line args are similar to env variables

```scala
val serverOpt = "abcde"
```

---

## A slide with evaluated code that is invisible in the presentation


---

class: center, middle

# Thanks!

Code and slides at `jisantuc/mdoc-presentations` on GitHub

## Questions?

---

# Attributions

- Mountain bike cat ([source](https://www.flickr.com/photos/zruda/3611699025), [license](https://creativecommons.org/licenses/by-nc-sa/2.0/))

 </textarea>
  <script src="remark-latest.min.js">
  </script>
  <script>
    var slideshow = remark.create();
  </script>
</body>

</html>